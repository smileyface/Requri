import tkinter as tk
from tkinter import ttk

from UI.pages.requirements import AddRequirementPage
# Generated by CodiumAI

from UI.pages.requirements.edit_requirement import EditRequirementPage

import pytest

from UI.pages.viewpage import ViewPage
from structures.lists import requirement_list
from structures.records import Requirement


class TestEditRequirementPage:

    #  Initializes correctly with all required attributes
    def test_initializes_correctly_with_all_required_attributes(self):
        root = tk.Tk()
        edit_page = EditRequirementPage(root)
        assert edit_page.section is None
        assert edit_page.subsection is None
        assert edit_page.requirement_text is None
        assert edit_page.title_entry is None
        assert edit_page.tagging_text is None
        assert edit_page.master == root
        assert edit_page.requirement is None

    #  Updates requirement in requirement_list when edit method is called
    def test_updates_requirement_in_requirement_list_when_edit_method_is_called(self):
        root = tk.Tk()
        edit_page = EditRequirementPage(root)
        edit_page.create_body()
        requirement = Requirement("Section", "Subsection", "Title", "Text", [])
        requirement_list.append(requirement)
        edit_page.requirement = requirement
        edit_page.section.variable.set("New Section")
        edit_page.subsection.variable.set("New Subsection")
        edit_page.title_entry.insert(0, "New Title")
        edit_page.requirement_text.insert("1.0", "New Text")
        edit_page.tagging_text.insert(0, "New Tag")
        edit_page.edit()
        updated_requirement = requirement_list.get(requirement.unique_id)
        assert updated_requirement.section == "New Section"
        assert updated_requirement.subsection == "New Subsection"
        assert updated_requirement.title == "New Title"
        assert updated_requirement.text == "New Text"
        assert updated_requirement.tags == ["New Tag"]

    #  Changes button text to "Edit" and sets the command to edit in create_context_nav
    def test_changes_button_text_to_edit_and_sets_command_to_edit_in_create_context_nav(self):
        root = tk.Tk()
        edit_page = EditRequirementPage(root)
        edit_page.add_button = tk.Button(root)
        edit_page.create_context_nav()
        assert edit_page.add_button.cget("text") == "Edit"
        assert edit_page.add_button.cget("command") == edit_page.edit

    #  Clears text fields and tagging list in on_hide
    def test_clears_text_fields_and_tagging_list_in_on_hide(self):
        root = tk.Tk()
        edit_page = EditRequirementPage(root)
        edit_page.requirement_text = tk.Text(root)
        edit_page.requirement_text.insert("1.0", "Some text")
        edit_page.title_entry = tk.Entry(root)
        edit_page.title_entry.insert(0, "Some title")
        edit_page.tagging_text = tk.Listbox(root)
        edit_page.tagging_text.insert(0, "Some tag")
        edit_page.on_hide()
        assert edit_page.requirement_text.get("1.0", tk.END).strip() == ""
        assert edit_page.title_entry.get() == ""
        assert not edit_page.tagging_text.size()

    #  Populates fields with requirement data in on_show
    def test_populates_fields_with_requirement_data_in_on_show(self):
        root = tk.Tk()
        requirement = Requirement("Section", "Subsection", "Title", "Text", ["Tag1"])
        requirement_list.append(requirement)
        edit_page = EditRequirementPage(root)
        edit_page.requirement = requirement
        edit_page.create_body()

        # Initialize fields that will be populated by on_show
        edit_page.title_entry = tk.Entry(root)
        edit_page.section = tk.StringVar()
        edit_page.subsection = tk.StringVar()
        edit_page.requirement_text = tk.Text(root)

        # Call on_show and check if it handles missing attributes gracefully
        try:
            edit_page.on_show()
            assert True  # If no exception is raised, the test passes
            assert edit_page.title_entry.get() == requirement.title
            assert edit_page.section.get() == requirement.section
            assert edit_page.subsection.get() == requirement.subsection
            assert edit_page.requirement_text.get("1.0", tk.END).strip() == requirement.text
            assert list(edit_page.tagging_text.get(0, tk.END)) == requirement.tags
        except Exception as e:
            pytest.fail(f"on_show raised an exception with missing attributes: {e}")

    #  Handles drag and drop events correctly in the traceability tab
    def test_handles_drag_and_drop_events_correctly_in_traceability_tab(self):
        root = tk.Tk()
        add_page = AddRequirementPage(root)

        # Initialize connected_listbox and connections list with sample data for testing purposes
        add_page.connected_listbox = ttk.Treeview(root)

        # Simulate drag and drop events in the traceability tab
        add_page.on_drag(tk.Event())
        add_page.on_drop(tk.Event())

        # Assert that the connections list is updated correctly
        assert len(add_page.connections) == 1

    #  Handles non-existent requirement in requirement_list in edit method
    def test_handles_non_existent_requirement_in_requirement_list_in_edit_method(self):
        root = tk.Tk()
        EditRequirementPage(root)
        non_existent_id = -1  # Assuming -1 is not a valid ID in requirement_list
        with pytest.raises(KeyError):
            requirement_list.update(non_existent_id, "Section", "Subsection", "Title", "Text", ["Tag"])

    #  Handles requirement with missing attributes in on_show
    def test_handles_requirement_with_missing_attributes_in_on_show(self):
        root = tk.Tk()
        incomplete_requirement = Requirement(None, None, None, None, None)
        incomplete_requirement.unique_id = 999  # Assign a unique ID for testing
        requirement_list.append(incomplete_requirement)

        edit_page = EditRequirementPage(root)
        edit_page.requirement = incomplete_requirement

        # Initialize fields that will be populated by on_show
        edit_page.title_entry = tk.Entry(root)
        edit_page.section = tk.StringVar()
        edit_page.subsection = tk.StringVar()
        edit_page.requirement_text = tk.Text(root)

        # Call on_show and check if it handles missing attributes gracefully
        try:
            edit_page.on_show()
            assert True  # If no exception is raised, the test passes
            assert not edit_page.title_entry.get()  # Should be empty since title is None
            assert not edit_page.section.get()  # Should be empty since section is None
            assert not edit_page.subsection.get()  # Should be empty since subsection is None
            assert not edit_page.requirement_text.get("1.0", tk.END).strip()  # Should be empty since text is None
            assert not list(edit_page.tagging_text.get(0, tk.END))  # Should be empty since tags are None
        except Exception as e:
            pytest.fail(f"on_show raised an exception with missing attributes: {e}")

    #  Handles empty or invalid input fields in submit_requirement
    def test_handles_empty_or_invalid_input_fields_in_submit_requirement(self):
        root = tk.Tk()

        add_page = AddRequirementPage(root)

        # Create entries with empty or invalid data
        add_page.entries = {
            "section": tk.Entry(root),
            "subsection": tk.Entry(root),
            "title": tk.Entry(root),
            "text": tk.Entry(root),
            "tags": tk.Entry(root)
        }

        # Leave all fields empty and call submit_requirement
        try:
            add_page.add()
            # Check if a new requirement was added despite empty fields (it shouldn't be added)
            assert len(add_page.connections) == 0

            # Now insert invalid data and call submit_requirement again
            add_page.entries["tags"].insert(0, "InvalidTagFormat")
            add_page.add()

            # Check if a new requirement was added despite invalid tags (it shouldn't be added)
            assert len(add_page.connections) == 0

            # If no exception is raised and no new requirement is added, the test passes
            assert True

        except Exception as e:
            pytest.fail(f"submit_requirement raised an exception with empty or invalid input fields: {e}")

    #  Handles empty connections list in update_listbox
    def test_handles_empty_connections_list_in_update_listbox(self):
        root = tk.Tk()

        add_page = AddRequirementPage(root)

        # Initialize connected_listbox and connections list as empty
        add_page.connected_listbox = ttk.Treeview(root)

        # Call update_listbox with empty connections list and check if it handles gracefully
        try:
            add_page.update_listbox()

            # Check if connected_listbox remains empty after update_listbox call
            assert len(add_page.connected_listbox.get_children()) == 0

            # If no exception is raised and connected_listbox remains empty, the test passes
            assert True

        except Exception as e:
            pytest.fail(f"update_listbox raised an exception with empty connections list: {e}")


    #  Handles selection events in the traceability tab
    def test_handles_selection_events_in_traceability_tab(self):
        root = tk.Tk()
        add_page = AddRequirementPage(root)
        add_page.create_body()

        # Simulate selection event in connectable listbox
        event = tk.Event()
        event.widget = add_page.connectable_listbox

        try:
            add_page.on_select(event)
            assert True  # If no exception is raised, the test passes

        except Exception as e:
            pytest.fail(f"on_select raised an exception during selection event handling in traceability tab: {e}")
