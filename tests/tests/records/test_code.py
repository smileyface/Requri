
# Generated by CodiumAI

import pytest

from src.structures.records.code import Code
from src.structures.records.code_location import Code_Location
from src.structures.records.record import Record


class TestCode:
    @pytest.fixture(autouse=True)
    def teardown(self):
        yield
        Record.clear_records()

    #  Initializes with all attributes correctly
    def test_initializes_with_all_attributes_correctly(self):
        definition_location = Code_Location(Code_Location.DEFINITION, "example_file.py", 10, 20)
        declaration_location = Code_Location(Code_Location.DECLARATION, "example_file.py", 30, 40)
        code_instance = Code("example_file.py", "public", "ExampleClass", "example_method", ["arg1", "arg2"], "func_begin", "func_end", definition_location, declaration_location)
        assert code_instance.file == "example_file.py"
        assert code_instance.access_level == "public"
        assert code_instance.class_name == "ExampleClass"
        assert code_instance.name == "example_method"
        assert code_instance.arguments == ["arg1", "arg2"]
        assert code_instance.func_begin == "func_begin"
        assert code_instance.func_end == "func_end"
        assert code_instance.definition == definition_location
        assert code_instance.declaration == declaration_location
        assert code_instance.unique_id == 0

    #  Generates unique ID when not provided
    def test_generates_unique_id_when_not_provided(self):
        code_instance = Code("example_file.py", "public", "ExampleClass", "example_method", ["arg1", "arg2"], "func_begin", "func_end")
        assert code_instance.unique_id is not None

    #  Returns correct signature string
    def test_returns_correct_signature_string(self):
        code_instance = Code("example_file.py", "public", "ExampleClass", "example_method", ["arg1", "arg2"], "func_begin", "func_end")
        assert code_instance.signature == "ExampleClass::example_method(arg1, arg2)"

    #  Converts to JSON format correctly
    def test_converts_to_json_format_correctly(self):
        definition_location = Code_Location(Code_Location.DEFINITION, "example_file.py", 10, 20)
        declaration_location = Code_Location(Code_Location.DECLARATION, "example_file.py", 30, 40)
        code_instance = Code("example_file.py", "public", "ExampleClass", "example_method", ["arg1", "arg2"], "func_begin", "func_end", definition_location, declaration_location)
        json_data = code_instance.to_json()
        assert json_data["id"] == code_instance.unique_id
        assert json_data["definition"] == definition_location.file
        assert json_data["declaration"] == declaration_location.file
        assert json_data["access"] == "public"
        assert json_data["class"] == "ExampleClass"
        assert json_data["name"] == "example_method"
        assert json_data["arguments"] == ["arg1", "arg2"]
        assert json_data["begin"] == "func_begin"
        assert json_data["end"] == "func_end"

    #  Connects to other records properly
    def test_connects_to_other_records_properly(self):
        code_instance = Code("example_file.py", "public", "ExampleClass", "example_method", ["arg1", "arg2"], "func_begin", "func_end")
        record_instance = Record(["tag1", "tag2"])
        code_instance.connect(record_instance)
        assert record_instance in code_instance.connections[Record]

    #  Sets unique ID correctly when provided
    def test_sets_unique_id_correctly_when_provided(self):
        code_instance = Code("example_file.py", "public", "ExampleClass", "example_method", ["arg1", "arg2"], "func_begin", "func_end", id=123)
        assert code_instance.unique_id == 123

    #  Raises error for non-unique ID
    def test_raises_error_for_non_unique_id(self):
        Code.id_map.add(123)
        with pytest.raises(ValueError, match="Non Unique ID"):
            Code("example_file.py", "public", "ExampleClass", "example_method", ["arg1", "arg2"], "func_begin", "func_end", id=123)

    #  Raises error for ID out of range
    def test_raises_error_for_id_out_of_range(self):
        with pytest.raises(ValueError, match="ID out of range"):
            Code("example_file.py", "public", "ExampleClass", "example_method", ["arg1", "arg2"], "func_begin", "func_end", id=1001)

    #  Handles missing definition or declaration gracefully
    def test_handles_missing_definition_or_declaration_gracefully(self):
        code_instance = Code("example_file.py", "public", "ExampleClass", "example_method", ["arg1", "arg2"], "func_begin", "func_end")
        json_data = code_instance.to_json()
        assert json_data["definition"] == ""
        assert json_data["declaration"] == ""

    #  Generates unique ID when ID map is near capacity
    def test_generates_unique_id_when_id_map_is_near_capacity(self):
        Code.id_map = set(range(999))
        code_instance = Code("example_file.py", "public", "ExampleClass", "example_method", ["arg1", "arg2"], "func_begin", "func_end")
        assert code_instance.unique_id == 999

    #  Handles empty argument list correctly
    def test_handles_empty_argument_list_correctly(self):
        code_instance = Code("example_file.py", "public", "ExampleClass", "example_method", [], "func_begin", "func_end")
        assert code_instance.signature == "ExampleClass::example_method()"

    #  Manages large number of connections efficiently
    def test_manages_large_number_of_connections_efficiently(self):
        code_instance = Code("example_file.py", "public", "ExampleClass", "example_method", ["arg1", "arg2"], "func_begin", "func_end")
        for i in range(1000):
            record_instance = Record([f"tag{i}"])
            code_instance.connect(record_instance)
        assert len(code_instance.connections[Record]) == 1000
