import tkinter as tk
from tkinter import ttk

# Generated by CodiumAI

from UI.pages.requirements.add_requirements.add_requirement import AddRequirementPage

import pytest

from structures.records import Code, Requirement


class TestAddRequirementPage:

    #  Successfully adds Code items to the treeview under 'Implementations'
    def test_adds_code_items_to_treeview_under_implementations(self):
        root = tk.Tk()
        treeview = ttk.Treeview(root)
        connected_items = [Code("file1", "public", "Class1", "method1", ["arg1", "arg2"], "func_begin1", "func_end1", True)]
        page = AddRequirementPage(root)
        page._add_lists_to_treeview(connected_items, treeview)
        assert treeview.get_children() == ('I001',)
        assert treeview.item('I001', 'text') == 'Implementations'
        assert treeview.get_children('I001') == ('Code-0',)
        root.destroy()

    #  Successfully adds Requirement items to the treeview under 'Related Requirements'
    def test_adds_requirement_items_to_treeview_under_related_requirements(self):
        root = tk.Tk()
        treeview = ttk.Treeview(root)
        connected_items = [Requirement("section1", "subsection1", "Title1", "Text1", ["tag1"])]
        page = AddRequirementPage(root)
        page._add_lists_to_treeview(connected_items, treeview)
        assert treeview.get_children() == ('I001',)
        assert treeview.item('I001', 'text') == 'Related Requirements'
        assert treeview.get_children('I001') == ('Req-section1-subsection1-0',)
        root.destroy()

    #  Handles mixed lists of Code and Requirement items correctly
    def test_handles_mixed_lists_of_code_and_requirement_items(self):
        root = tk.Tk()
        treeview = ttk.Treeview(root)
        connected_items = [
            Code("file1", "public", "Class1", "method1", ["arg1", "arg2"], "func_begin1", "func_end1", True),
            Requirement("section1", "subsection1", "Title1", "Text1", ["tag1"])
        ]
        page = AddRequirementPage(root)
        page._add_lists_to_treeview(connected_items, treeview)
        assert len(treeview.get_children()) == 2
        assert treeview.item(treeview.get_children()[0], 'text') == 'Related Requirements'
        assert treeview.item(treeview.get_children()[1], 'text') == 'Implementations'
        root.destroy()

    #  Maintains the order of items as per the input list
    def test_maintains_order_of_items_as_per_input_list(self):
        root = tk.Tk()
        treeview = ttk.Treeview(root)
        connected_items = [
            Requirement("section1", "subsection1", "Title1", "Text1", ["tag1"]),
            Code("file2", "private", "Class2", "method2", ["arg3", "arg4"], "func_begin2", "func_end2", False)
        ]
        page = AddRequirementPage(root)
        page._add_lists_to_treeview(connected_items, treeview)
        children = treeview.get_children()
        assert len(children) == 2
        assert treeview.item(children[0], 'text') == 'Related Requirements'
        assert treeview.item(children[1], 'text') == 'Implementations'
        root.destroy()

    #  Handles empty lists without errors
    def test_handles_empty_list_without_errors(self):
        root = tk.Tk()
        treeview = ttk.Treeview(root)
        connected_items = []
        page = AddRequirementPage(root)
        page._add_lists_to_treeview(connected_items, treeview)
        assert len(treeview.get_children()) == 0
        root.destroy()

    #  Manages lists with only Code items
    def test_manages_lists_with_only_code_items(self):
        root = tk.Tk()
        treeview = ttk.Treeview(root)
        connected_items = [
            Code("file1", "public", "Class1", "method1", ["arg1", "arg2"], "func_begin1", "func_end1", True),
        ]
        page = AddRequirementPage(root)
        page._add_lists_to_treeview(connected_items, treeview)
        assert len(treeview.get_children()) == 1
        assert treeview.item(treeview.get_children()[0], 'text') == 'Implementations'
        root.destroy()


    #  Handles missing or None unique IDs
    def test_handles_missing_or_none_unique_ids(self):
        root = tk.Tk()
        treeview = ttk.Treeview(root)
        connected_items = [
            Code("file1", "public", "Class1", "method1", ["arg1", "arg2"], "func_begin1", "func_end1", True),
            Requirement("section1", "subsection1", "Title1", "Text1", ["tag1"], unique_id=None)
        ]
        page = AddRequirementPage(root)
        page._add_lists_to_treeview(connected_items, treeview)
        assert len(treeview.get_children()) == 2
        root.destroy()

    #  Logs errors when insertion fails
    def test_logs_errors_when_insertion_fails(self):
        root = tk.Tk()
        treeview = ttk.Treeview(root)

        class FaultyCode(Code):
            @property
            def unique_id(self):
                raise ValueError("Faulty ID")

        connected_items = [FaultyCode("file3", "protected", "Class3", "method3", ["arg5"], "", "", True)]

        page = AddRequirementPage(root)

        with pytest.raises(ValueError):
            page._add_lists_to_treeview(connected_items, treeview)

    #  Handles faulty Code items that raise exceptions
    def test_handles_faulty_code_items_that_raise_exceptions(self):
        root = tk.Tk()
        treeview = ttk.Treeview(root)

        class FaultyCode(Code):
            @property
            def unique_id(self):
                raise ValueError("Faulty ID")

        connected_items = [FaultyCode("file3", "protected", "Class3", "method3", ["arg5"], "", "", True)]

        page = AddRequirementPage(root)

        with pytest.raises(ValueError):
            page._add_lists_to_treeview(connected_items, treeview)

    #  Handles drag and drop events with invalid data
    def test_handles_drag_and_drop_events_with_invalid_data(self):
        root = tk.Tk()
        page = AddRequirementPage(root)

        class MockEvent:
            def __init__(self, widget, x_root, y_root):
                self.widget = widget
                self.x_root = x_root
                self.y_root = y_root

            @property
            def x(self):
                return self.x_root

            @property
            def y(self):
                return self.y_root

        mock_widget = tk.Label(root, text='mock_widget')
    
        mock_widget._drag_data = None  # Invalid data

        event = MockEvent(mock_widget, 100, 100)

        page.on_drop(event)  # Should handle gracefully without errors

    #  Manages lists with only Requirement items
    def test_manages_lists_with_only_requirement_items(self):
        root = tk.Tk()
        treeview = ttk.Treeview(root)
        connected_items = [
            Requirement("section1", "subsection1", "Title1", "Text1", ["tag1"]),
            Requirement("section2", "subsection2", "Title2", "Text2", ["tag2"])
        ]
        page = AddRequirementPage(root)
        page._add_lists_to_treeview(connected_items, treeview)
        assert len(treeview.get_children()) == 2
        assert treeview.item(treeview.get_children()[0], 'text') == 'Related Requirements'
        root.destroy()

    #  Handles large lists efficiently
    def test_handles_large_lists_efficiently(self):
        root = tk.Tk()
        treeview = ttk.Treeview(root)

        connected_items = [Code(f"file{i}", f"access{i}", f"Class{i}", f"method{i}", [f"arg{i}"], f"begin{i}", f"end{i}", True) for i in range(1000)]

        page = AddRequirementPage(root)

        import time
        start_time = time.time()

        page._add_lists_to_treeview(connected_items, treeview)

        end_time = time.time()

        assert (end_time - start_time) < 5  # Ensure it runs within 5 seconds for 1000 items

        root.destroy()
